<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Maze</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<style>
* {
  margin: 0;
  padding: 0;
}
body {
  overflow: hidden;
  background-color: #333;
}
</style>
</head>
<body>

  <canvas 
    id="display" 
    ></canvas>

<script>
var graph;
var canvas;
var start;
var end;
var walls = [];
var midX, midY;

// Exclusive! 
var rand = function(num) {
  return Math.floor(Math.random()*num);
};

// Returns a tuple with a random coordinate picked out from the input graph
var pickRandomCell = function() {
  var y = rand(graph.length);
  var x = rand(graph[0].length);
  return [y, x];
};

var generateSquareGraph = function(sizeY, sizeX) {
  var graph = [];
  for (var i=0; i<sizeY; i++) {
    graph[i] = [];
    for (var j=0; j<sizeX; j++) {
      graph[i][j] = false; // false == wall
    }
  }
  return graph;
};

var resetCanvasAspect = window.onresize = function() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
};

var neighboringWallsOfCell = function(cell) {
  return [[-1, 0], [1, 0], [0, -1], [0, 1]].map(function(dir) {
    var y = cell[0] + dir[0];
    var x = cell[1] + dir[1];
    return [y, x];
  }).filter(function(c) {
    return graph[c[0]] && graph[c[0]][c[1]] === false;
  });
};

var randomNeighborCell = function(cell) {
  var neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]].map(function(dir) {
    var y = cell[0] + dir[0];
    var x = cell[1] + dir[1];
    return [y, x];
  }).filter(function(c) {
    return isCell(c);
  });
  if (!neighbors.length) {
    console.log("no cells");
  }
  else {
    return neighbors[rand(neighbors.length)];
  }
};
var shuffleArray = function(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
  return array;
};


var draw = function() {

  // Clear canvas <- unecessary (aw, yeah! this eliminates the artifacting!)
  //ctx.clearRect(0, 0, canvas.width, canvas.height);

  graph.forEach(function(row, y) {
    row.forEach(function(col, x) {

      var rectWidth = window.innerWidth / graph[0].length;
      var rectHeight = window.innerHeight / graph.length;
      var rectX = x * rectWidth;
      var rectY = y * rectHeight;

      // Luminance is a function of the manhattan distance from the center (mid)

      if (isCell([y, x])) {
/*
        if (y == 0) {
          var lum = Math.abs(x - midX) + Math.abs(y - midY);
          console.log(lum);
        }
*/
        ctx.fillStyle = "hsl("+ graph[y][x] +", 50%, 50%)";
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
      }

    });
  });
};

var oppositeCell = function(from, to) {
  var yDiff = to[0] - from[0];
  var xDiff = to[1] - from[1];
  var coord = [to[0] + yDiff, to[1] + xDiff];
  return at(coord) !== undefined ? coord : null;
};

var at = function(coord) {
  return coord && graph[coord[0]] && graph[coord[0]][coord[1]];
}; 

var isCell = function(coord) {
  var cell = at(coord);
  return cell !== false && cell !== undefined;
};

canvas = document.getElementById("display");
if (canvas.getContext) {
  ctx = canvas.getContext("2d");
}
else {
  alert("Please switch to a browser that supports canvas.");
}
resetCanvasAspect();

var factor = 8;
var sizeY = Math.floor(window.innerHeight / factor);
var sizeX = Math.floor(window.innerWidth / factor);
graph = generateSquareGraph(sizeY, sizeX);
midY = Math.floor(graph.length / 2);
midX = Math.floor(graph[0].length / 2);
var current = [midY, midX];
graph[current[0]][current[1]] = rand(256);
walls = walls.concat(neighboringWallsOfCell(current));

/*
var another = pickRandomCell();
graph[another[0]][another[1]] = rand(256);
walls = walls.concat(neighboringWallsOfCell(another));

var yetanother = pickRandomCell();
graph[yetanother[0]][yetanother[1]] = rand(256);
walls = walls.concat(neighboringWallsOfCell(yetanother));
*/

// Pick a random wall from the list
//var interv = setInterval(function() {
var interv = function() {

  if (!walls.length) {
    clearInterval(interv);
    console.log("no more walls"); 
    return;
  }


  var wall = walls[rand(walls.length)];
  var cell = randomNeighborCell(wall);
  var opposite = oppositeCell(cell, wall);
  if (opposite && !isCell(opposite)) {
    var off = 9;
    var diff = rand(off*2) - off;
    var newWallHue = at(cell) + diff;
    if (newWallHue < 0) {
      newWallHue = 0; 
    }
    if (newWallHue > 255) {
      newWallHue = 255;
    }
    var diff = rand(off*2) - off;
    graph[wall[0]][wall[1]] = newWallHue; 
    var newOppHue = at(cell) + diff;
    if (newOppHue < 0) {
      newOppHue = 0; 
    }
    if (newOppHue > 255) {
      newOppHue = 255;
    }
    graph[opposite[0]][opposite[1]] = newOppHue; 
    walls = walls.concat(neighboringWallsOfCell(opposite));
  }
  var i = walls.indexOf(wall);
  if (!!~i) walls.splice(i, 1);
};
//}, 10);

/*
while (walls.length) {
  // Pick a random wall in the list
  var wall = rand(walls.length);
  var cell = randomNeighborCell(wall);
  // If the cell on the opposite side isn't in the maze yet:
    // Make the wall a passage and mark the cell on the opposite side as part of the maze
    // Add the neighboring walls of the cell to the wall list
  // If the cell on the opposite side already was in the maze, remove the wall from the list
}
*/

window.requestAnimFrame = (function(){
  return window.requestAnimationFrame       ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame    ||
         function(callback) {
           window.setTimeout(callback, 1000 / 60);
         };
})();

(function animloop(){
  requestAnimFrame(animloop);
  if (walls.length) {
    for (var i=0; i<5; i++) {
      interv();
    }
    draw();
  }
})();

</script>


</body>
</html>
