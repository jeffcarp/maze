<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Maze</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<style>
* {
  margin: 0;
  padding: 0;
}
body {
  background-color: #222;
}
</style>
</head>
<body>

  <canvas 
    id="display" 
    ></canvas>

<script>
var graph;
var canvas;
var start;

var dfs = function() {

  canvas = document.getElementById("display");
  if (canvas.getContext) {
    ctx = canvas.getContext("2d");
  }
  else {
    alert("Please switch to a browser that supports canvas.");
  }
  resetCanvasAspect();

  graph = generateSquareGraph(20);
  var current = pickRandomCell(graph);
  graph[current[0]][current[1]] += 's';
  start = current.slice();
  var end = pickRandomCell(graph);
  graph[end[0]][end[1]] += 'e';
  // Start at a particular cell and call it the 'exit'
  recurse(current);
  draw(graph);
};

var foo = 0;
var recurse = function(current) {
  // Mark the current cell as visited, and get a list of neighbors. For each neighbor, starting with a randomly selected neighbor:
  graph[current[0]][current[1]] += 'v';
  graph[current[0]][current[1]] += ' ' + foo++;

  getNeighbors(current).forEach(function(neighbor) {
    // If that neighbor hasn't been visited, 
    if (!!~graph[neighbor[0]][neighbor[1]].indexOf('v')) return;
    // remove the wall between this cell and that neighbor, 
    removeWallBetween(current, neighbor);
    // and then recurse with that neighbor as the current cell
    recurse(neighbor);
  });
};

var getNeighbors = function(cell) {
  var neighbors = [
    [cell[0]-1, cell[1]], // up    (y-1, x)
    [cell[0]+1, cell[1]], // down  (y+1, x)
    [cell[0], cell[1]-1], // left  (y, x-1)
    [cell[0], cell[1]+1]  // right (y, x+1)
  ];
  neighbors = neighbors.filter(function(coord) {
    return (
      coord[0] >= 0           &&
      coord[0] < graph.length &&
      coord[1] >= 0           &&
      coord[1] < graph.length
    );
  });
  return shuffleArray(neighbors);
};

// Takes two tuples, a and b (in (y, x) format)
// Removes the character denoting the wall in between them
var removeWallBetween = function(a, b) {
  // b is below a, remove a's bottom (and b's top?) this makes no sense
  if (a[0]+1 === b[0]) {
    removeChar(a, 'b'); 
    removeChar(b, 't'); 
  }
  // b is above a, remove b's bottom and a's top
  else if (a[0]-1 === b[0]) {
    removeChar(a, 't'); 
    removeChar(b, 'b'); 
  }
  // b is to the right of a, remove b's left and a's right 
  else if (a[1]+1 === b[1]) {
    removeChar(a, 'r'); 
    removeChar(b, 'l'); 
  }
  // b is to the left of a, remove b's right and a's left 
  else if (a[1]-1 === b[1]) {
    removeChar(a, 'l'); 
    removeChar(b, 'r'); 
  }
};

var removeChar = function(coord, chr) {
  var str = graph[coord[0]][coord[1]].replace(chr, "");
  graph[coord[0]][coord[1]] = str;
};

var generateSquareGraph = function(size) {
  var graph = [];
  for (var i=0; i<size; i++) {
    graph[i] = [];
    for (var j=0; j<size; j++) {
      graph[i][j] = "tblr";
    }
  }
  return graph;
};

// Returns a tuple with a random coordinate picked out from the input graph
var pickRandomCell = function(graph) {
  var y = rand(graph.length);
  var x = rand(graph.length);
  return [y, x];
};

// Exclusive! 
var rand = function(num) {
  return Math.floor(Math.random()*num);
};

var shuffleArray = function(array) {
  for (var i = array.length - 1; i > 0; i--) {
    var j = Math.floor(Math.random() * (i + 1));
    var temp = array[i];
    array[i] = array[j];
    array[j] = temp;
  }
  return array;
};

var draw = function(graph) {

  // Clear canvas
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  graph.forEach(function(row, y) {
    row.forEach(function(col, x) {

      var rectWidth = window.innerWidth / graph.length;
      var rectHeight = window.innerHeight / graph.length;
      var rectX = x * rectWidth;
      var rectY = y * rectHeight;

      var borderWidth = 1;

      // Paint edges
      ctx.fillStyle = "white";
      if (!!~col.indexOf("t")) {
        ctx.fillRect(rectX, rectY, rectWidth, borderWidth);
      }
      if (!!~col.indexOf("b")) {
        ctx.fillRect(rectX, rectY+rectHeight-borderWidth, rectWidth, borderWidth);
      }
      if (!!~col.indexOf("l")) {
        ctx.fillRect(rectX, rectY, borderWidth, rectHeight);
      }
      if (!!~col.indexOf("r")) {
        ctx.fillRect(rectX+rectWidth-borderWidth, rectY, borderWidth, rectHeight);
      }
      if (!!~col.indexOf("s")) {
        ctx.fillStyle = "orange";
        ctx.fillRect(rectX+borderWidth, rectY+borderWidth, rectWidth-borderWidth*2, rectHeight-borderWidth*2);
      }
      if (!!~col.indexOf("e")) {
        ctx.fillStyle = "red";
        ctx.fillRect(rectX+borderWidth, rectY+borderWidth, rectWidth-borderWidth*2, rectHeight-borderWidth*2);
      }

    });
  });
};

var resetCanvasAspect = function() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  graph && draw(graph);
};

// 1st solve function: just take right turns and backtrack until you find the end
// (DFS)
var solve = function() {
  var curPos = start;
  console.log("solve, curPos:", curPos);
  var solveIntv = setInterval(function() {
    // Just get all non-border sides
    var neighbors = getNeighbors(curPos);
    console.log("neighbors", neighbors);
  }, 2e3);
};

window.onresize = resetCanvasAspect;

dfs();
solve();
</script>


</body>
</html>
