<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Maze</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

<style>
* {
  margin: 0;
  padding: 0;
}
body {
  overflow: hidden;
  background-color: #333;
}
</style>
</head>
<body>

  <canvas 
    id="display" 
    ></canvas>

<script>
var graph;
var canvas;
var start;
var end;
var walls = [];
var midX, midY;

var rand = function(num) {
  // Exclusive! 
  return Math.floor(Math.random()*num);
};

// Returns a tuple with a random coordinate picked out from the input graph
var pickRandomCell = function() {
  var y = rand(graph.length);
  var x = rand(graph[0].length);
  return [y, x];
};

var generateSquareGraph = function(sizeY, sizeX) {
  var graph = [];
  for (var i=0; i<sizeY; i++) {
    graph[i] = [];
    for (var j=0; j<sizeX; j++) {
      graph[i][j] = false; // false == wall
    }
  }
  return graph;
};

var resetCanvasAspect = window.onresize = function() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
};

var neighboringWallsOfCell = function(cell) {
  return [[-1, 0], [1, 0], [0, -1], [0, 1]].map(function(dir) {
    var y = cell[0] + dir[0];
    var x = cell[1] + dir[1];
    return [y, x];
  }).filter(function(c) {
    return graph[c[0]] && graph[c[0]][c[1]] === false;
  });
};

var randomNeighborCell = function(cell) {
  var neighbors = [[-1, 0], [1, 0], [0, -1], [0, 1]].map(function(dir) {
    var y = cell[0] + dir[0];
    var x = cell[1] + dir[1];
    return [y, x];
  }).filter(function(c) {
    return isCell(c);
  });
  if (!neighbors.length) {
    console.log("no cells");
  }
  else {
    return neighbors[rand(neighbors.length)];
  }
};

var draw = function() {
  window.cellCount = 0;
  window.wallCount = 0;
  graph.forEach(function(row, y) {
    row.forEach(function(col, x) {

      var rectWidth = window.innerWidth / graph[0].length;
      var rectHeight = window.innerHeight / graph.length;
      var rectX = x * rectWidth;
      var rectY = y * rectHeight;
        

      if (isCell([y, x])) {
        cellCount++;
        ctx.fillStyle = "hsl("+ graph[y][x] +", 50%, 50%)";
        ctx.fillRect(rectX, rectY, rectWidth, rectHeight);
        
        // TODO: If a cell's neighbors of depth 2 are all filled out, remove this cell (and its walls?)
      } 
      else {
        wallCount++;
      }

    });
  });
};

var oppositeCell = function(from, to) {
  var yDiff = to[0] - from[0];
  var xDiff = to[1] - from[1];
  var coord = [to[0] + yDiff, to[1] + xDiff];
  return at(coord) !== undefined ? coord : null;
};

var at = function(coord) {
  return coord && graph[coord[0]] && graph[coord[0]][coord[1]];
}; 

var isCell = function(coord) {
  var cell = at(coord);
  return cell !== false && cell !== undefined;
};

canvas = document.getElementById("display");
if (canvas.getContext) {
  ctx = canvas.getContext("2d");
}
else {
  alert("To view please use a browser that supports canvas.");
}
resetCanvasAspect();

var factor = 10;
var sizeY = Math.floor(window.innerHeight / factor);
var sizeX = Math.floor(window.innerWidth / factor);
graph = generateSquareGraph(sizeY, sizeX);
midY = Math.floor(graph.length / 2);
midX = Math.floor(graph[0].length / 2);
var current = [midY, midX];
graph[current[0]][current[1]] = rand(256);
walls = walls.concat(neighboringWallsOfCell(current));

// Pick a random wall from the list
var interv = function() {

  if (!walls.length) {
    console.log("no more walls"); 
    return;
  }

  var wall = walls[rand(walls.length)];
  var cell = randomNeighborCell(wall);
  var opposite = oppositeCell(cell, wall);
  if (opposite && !isCell(opposite)) {
    var off = 9;
    var diff = rand(off*2) - off;
    var newWallHue = at(cell) + diff;
    if (newWallHue < 0) {
      newWallHue = 0; 
    }
    if (newWallHue > 255) {
      newWallHue = 255;
    }
    var diff = rand(off*2) - off;
    graph[wall[0]][wall[1]] = newWallHue; 
    var newOppHue = at(cell) + diff;
    if (newOppHue < 0) {
      newOppHue = 0; 
    }
    if (newOppHue > 255) {
      newOppHue = 255;
    }
    graph[opposite[0]][opposite[1]] = newOppHue; 
    walls = walls.concat(neighboringWallsOfCell(opposite));
  }
  var i = walls.indexOf(wall);
  if (!!~i) walls.splice(i, 1);
};

/*
while (walls.length) {
  // Pick a random wall in the list
  var wall = rand(walls.length);
  var cell = randomNeighborCell(wall);
  // If the cell on the opposite side isn't in the maze yet:
    // Make the wall a passage and mark the cell on the opposite side as part of the maze
    // Add the neighboring walls of the cell to the wall list
  // If the cell on the opposite side already was in the maze, remove the wall from the list
}
*/

window.requestAnimFrame = (function(){
  return (
    window.requestAnimationFrame       ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame    ||
    window.setTimeout.bind(this, callback, 1000 / 60));
})();

(function animationLoop() {
  if (walls.length) {
    interv();
    draw();
    requestAnimFrame(animationLoop);
  } else {
    console.log("Done.");
  }
})();

</script>


</body>
</html>
